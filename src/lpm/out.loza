#!/usr/bin/env loza
$__ismain__ = False;ns lpm;ns cmdline;@doc """Contains the parsed arguments.""";class ParsedArgs;func __init__(array[string] $arguments=[], dict $options={});$this->arguments = $arguments;$this->options = $options;endfunc ;@doc "Gets a option name and returns boolean that is option inserted or not";func bool::has_option(string $name);return $name in list($this->options->keys());endfunc ;@doc """Gets name of a option and returns value of that.     Also you can pass a second argument named `default`. if option not inserted, returns default.     The default value of this argument is `null`.    """;func get_option_value(string $name, $default = null);if not $this->has_option($name);return $default;endif ;return $this->options[$name];endfunc ;@doc """    Validates the inserted options.     Gets configuration as a dictionary.    """;func validate(dict $config);$config->setdefault ('options', {});$config->setdefault ('only_known_options', true);$config->setdefault ('min_args', null);$config->setdefault ('max_args', null);$options = $config['options'];$options_keys = list($options->keys());$result = true;$i = 0;while $i < len($options_keys);$name = $options_keys[$i];$option = $options[$name];if typeof($option) == dict;$option->setdefault ('required', false);$option->setdefault ('default_value', null);$option->setdefault ('value_required', false);if $option['required'];if not $this->has_option($name);$result = 'option ' + $name + ' is required';break ;endif ;endif ;if $option['value_required'];if $this->get_option_value($name) is null;$result = 'option ' + $name + ' required parameter';break ;endif ;endif ;if $option['default_value'] is not null;$this->options->setdefault ($name, $option['default_value']);endif ;endif ;$i = $i + 1;endwhile ;if $config['only_known_options'];$i = 0;$inserted_options_keys = list($this->options->keys());while $i < len($inserted_options_keys);if $inserted_options_keys[$i] not in $options_keys;$result = 'unknow option ' + $inserted_options_keys[$i];break ;endif ;$i = $i + 1;endwhile ;endif ;if $config['min_args'] is not null;if len($this->arguments) < $config['min_args'];$result = 'this command requires minimum ' + str($config['min_args']) + ' arguments';endif ;endif ;if $config['max_args'] is not null;if len($this->arguments) > $config['max_args'];$result = 'this command requires maximum ' + str($config['max_args']) + ' arguments';endif ;endif ;return $result;endfunc ;endclass ;@doc """Gets command line arguments as a list and parses them. Returns a ParsedArgs object.""";func parse_args(array[string] $args);$arguments = [];$options = {};$i = 0;while $i < len($args);if $args[$i];if $args[$i]->startswith('-');$op_name = $args[$i]->split('=', 1);$op_value = null;if len($op_name) > 1;$op_value = $op_name[1];endif ;$op_name = $op_name[0];$options[$op_name] = $op_value;else ;$arguments->append ($args[$i]);endif ;endif ;$i = $i + 1;endwhile ;return ParsedArgs($arguments, $options);endfunc ;endns ;endns ;$__ismain__ = True;$__ismain__ = False;$__ismain__ = False;$__ismain__ = False;ns lpm;@doc "Print info texts";func print_info(string $txt);if LPM_LOG_INFO;print $txt;endif ;endfunc ;@doc "Print logs texts";func print_log(string $txt);if LPM_LOG_LOG;print $txt;endif ;endfunc ;@doc "Print warnings";func print_warn(string $txt);if LPM_LOG_WARN;perror $txt;endif ;endfunc ;@doc "Print errors";func print_err(string $txt);if LPM_LOG_ERR;perror $txt;endif ;endfunc ;endns ;$__ismain__ = False;ns lpm;ns commands;@doc """LPM - The Loza programming language package manager\n\nUsage: lpm [subcommand] [options...] [arguments...]\n\nGeneral options:\n    --help: shows help of a command\n    --version: shows version of the LPM\n    --global|-g: enable global mode (for installing/listing packages)\n    -q: quiet (level 1)\n    -qq: quiet (level 2)\n    -qqq: quiet (level 3)\n    -qqqq: quiet (level 4)\n""";func index_cmd($args);if $args->has_option('--version');println '0.0.1';return 0;endif ;println lpm.commands.index_cmd->__docstring__;println '\nCommands:';$i = 0;$keys = list($lpm.commands.list->keys());while $i < len($keys);if $keys[$i] != 'index';println '    ' + $keys[$i] + '\t\t' + $lpm.commands.list[$keys[$i]]->__docstring__->strip()->splitlines()[0]->strip();endif ;$i = $i + 1;endwhile ;endfunc ;endns ;endns ;$__ismain__ = False;$__ismain__ = False;$__ismain__ = False;$__ismain__ = False;ns lpm;@doc """Parses the `LPMfile` file to load configuration of a package""";class LPMFile;$raw_options = {};@doc "Loads LPMfile from a filepath";func lpm.LPMFile::load_f(string $filepath);$f = open($filepath, 'r');$content = $f->read();$f->close ();return lpm.LPMFile->loads($content);endfunc ;@doc "Parses content of lpmfile as string";func lpm.LPMFile::loads(string $content);$i = 0;$lines = $content->splitlines();$orig_lines = [];while $i < len($lines);$line = $lines[$i]->strip();if $line != '';$line = $line->split('#', 1)[0]->strip();if $line;$orig_lines->append ($line);endif ;endif ;$i = $i + 1;endwhile ;$result = lpm.LPMFile();$result->raw_options->setdefault ('require', []);$result->raw_options->setdefault ('conflict', []);$result->raw_options->setdefault ('path', []);$result->raw_options->setdefault ('script', []);$i = 0;while $i < len($orig_lines);$parts = $orig_lines[$i]->split(' ', 1);$name = $parts[0]->strip()->lower();$value = $parts[1]->strip();if $name in ('require', 'conflict', 'path', 'script');$result->raw_options[$name]->append ($value);else ;$result->raw_options[$name] = $value;endif ;$i = $i + 1;endwhile ;$result->parse_options ();return $result;endfunc ;@doc "Reads the raw options and puts them in seprated fields";func parse_options();$this->raw_options->setdefault ('name', '');$this->raw_options->setdefault ('description', '');$this->raw_options->setdefault ('description_file', '');$this->raw_options->setdefault ('author', '');$this->raw_options->setdefault ('license', '');$this->raw_options->setdefault ('default_script', None);$i = 0;$keys = list($this->raw_options->keys());while $i < len($keys);$k = $keys[$i];$v = $this->raw_options[$k];if $k == 'name';$this->name = $v;elif $k == 'description';$this->description = $v;elif $k == 'description_file';$this->description_file = $v;elif $k == 'require';$this->require = $v;elif $k == 'conflict';$this->conflict = $v;elif $k == 'path';$this->path = $v;elif $k == 'author';$this->author = $v;elif $k == 'license';$this->license = $v;elif $k == 'script';$this->script = $v;elif $k == 'default_script';$this->default_script = $v;endif ;$i = $i + 1;endwhile ;endfunc ;endclass ;endns ;$__ismain__ = False;$__ismain__ = False;ns lpm;ns version;@doc "Converts non-numeric chars to their code and returns new filtered string";func string::try_parse_int(string $str);$i = 0;$valid_str = '';$numbers = '0123456789-';while $i < len($str);if $str[$i] in $numbers;$valid_str = $valid_str + $str[$i];else ;$valid_str = $valid_str + '.' + str(ord($str[$i])) + '.';endif ;$i = $i + 1;endwhile ;if $valid_str == '';$valid_str = '0';endif ;$valid_str = $valid_str->replace('..', '.')->strip();if $valid_str == '';$valid_str = '0';endif ;return $valid_str;endfunc ;@doc "Parses a version from string";func list::parse(string $version);$version = $version->lstrip('v');$version = $version->lstrip('V');$numbers = $version->replace('-', '.-1.')->split('.');$i = 0;while $i < len($numbers);$tmp = try_parse_int(str($numbers[$i]))->split('.');$tmp = list(map(int, [item for item in $tmp if item != '']));$numbers[$i:$i+1] = $tmp;$i = $i + len($tmp);endwhile ;return $numbers;endfunc ;@doc """Compares two version strings. Returns 1 if a is bigger than b, 0 is two versions are equal, and -1 if a is less than b.""";func int::compare(list|string $a, list|string $b);if typeof($a) == string;$v_a = lpm.version.parse($a);else ;$v_a = $a;endif ;if typeof($a) == string;$v_b = lpm.version.parse($b);else ;$v_b = $b;endif ;$i = 0;while $i < len($v_a) or $i < len($v_b);if $i >= len($v_b);if $v_a[$i] == -1;return -1;else ;return 1;endif ;elif $i >= len($v_a);if $v_b[$i] == -1;return 1;else ;return -1;endif ;endif ;if $v_a[$i] > $v_b[$i];return 1;elif $v_a[$i] < $v_b[$i];return -1;endif ;$i = $i + 1;endwhile ;return 0;endfunc ;@doc "Gets a list from versions and sorts them";func list::sort_list(list $versions);$sorted_versions = [];while len($versions) > 0;$i = 0;while $i < len($versions);$j = 0;$is_bigger_than_all = true;while $j < len($versions);if lpm.version.compare($versions[$i], $versions[$j]) < 0;$is_bigger_than_all = false;endif ;$j = $j + 1;endwhile ;if $is_bigger_than_all;$sorted_versions->insert (0, $versions->pop($i));endif ;$i = $i + 1;endwhile ;endwhile ;return $sorted_versions;endfunc ;endns ;endns ;$__ismain__ = False;$__ismain__ = False;ns lpm;ns http;@doc "Makes a HTTP request to a URL.\nArg `url` is the url as string.\nArg `method` is the HTTP method (default GET).\nArg `data` is the payload.\nArg `headers` is the headers as dictionary.";func req(string $url, string $method = 'GET', $data = null, dict $headers = {});$method = $method->upper();if not 'Content-Type' in $headers->keys();$headers['Content-Type'] = 'application/x-www-form-urlencoded';endif ;if not 'User-Agent' in $headers->keys();$headers['User-Agent'] = 'LPM';endif ;if $data is not null;$data = py_load_module('urllib.parse')->urlencode($data)->encode();endif ;$parsed_url = py_load_module('urllib.parse')->urlparse($url);if $parsed_url->scheme == 'https';$con = py_load_module('http.client')->HTTPSConnection($parsed_url->netloc);else ;$con = py_load_module('http.client')->HTTPConnection($parsed_url->netloc);endif ;if $parsed_url->query != '';$path = $parsed_url->path + '?' + $parsed_url->query;if $path->startswith('?');$path = '/' + $path;endif ;else ;$path = $parsed_url->path;endif ;$con->request ($method, $path, body=$data, headers=$headers);return $con->getresponse();endfunc ;endns ;endns ;$__ismain__ = False;$__ismain__ = False;ns lpm;$cache_dir = string(py_load_module('pathlib')->Path()->home()) + '/.lpm_cache';endns ;$__ismain__ = False;import_once "@hash";ns lpm;@doc "Package driver for local file directories";class FileDriver;func __init__(string $address);$this->error = null;$this->address = $address;if not os.path.isdir($this->address);$this->error = 'Directory "'+$this->address+'" not found';return ;endif ;$this->address = os.path.abspath($this->address);if not os.path.isdir($this->address + '/.git');$this->error = 'Directory "'+$this->address+'" is not a Git repository';return ;endif ;try lpm_package_version_load_error;$this->versions = $this->load_versions();endtry ;goto after_lpm_package_version_load_error;label lpm_package_version_load_error;$this->error = 'Faild to load list of versions of '+$this->address+': ' + string(^);return ;label after_lpm_package_version_load_error;endfunc ;@doc "Returns list of versions";func load_versions();$this->default_branch = null;$branches = $this->get_branches();if 'main' in $branches;$this->default_branch = 'main';elif 'dev' in $branches;$this->default_branch = 'dev';elif 'devel' in $branches;$this->default_branch = 'devel';elif 'develop' in $branches;$this->default_branch = 'develop';elif 'master' in $branches;$this->default_branch = 'master';else ;$this->default_branch = $branches[0];endif ;$list = os.listdir($this->address + '/.git/refs/tags');if not $list;$list = [$this->default_branch];endif ;return $list;endfunc ;@doc "Gets a version and file name and loads the file in that version";func string::load_file_content(string $version, string $filename);$old_cwd = os.getcwd();os.chdir ($this->address);$cmd = 'git show ' + repr($version + ':' + $filename);try lpm_package_handle_git_command_error;$output = subprocess.check_output($cmd, shell=true)->decode();endtry ;goto after_lpm_package_handle_git_command_error;label lpm_package_handle_git_command_error;$output = '';label after_lpm_package_handle_git_command_error;os.chdir ($old_cwd);return $output;endfunc ;@doc "Loads `LPMfile` of a specify version";func string::load_once_version(string $version);return $this->load_file_content($version, 'LPMfile');endfunc ;@doc "Copies package directory to the target path";func download(string $path, string $version);if os.path.isdir($path);py_load_module ('shutil')->rmtree($path);endif ;py_load_module ('shutil')->copytree($this->address, $path);$old_cwd = os.getcwd();os.chdir ($path);system ('git checkout -q -b lpm-installation ' + repr($version));os.chdir ($old_cwd);endfunc ;@doc "Returns list of repo branches";func list[string]::get_branches();return os.listdir($this->address + '/.git/refs/heads');endfunc ;endclass ;@doc "Package driver for GitHub repositories";class GithubDriver;func __init__(string $address);$this->error = null;$this->address = $address;try lpm_github_init;$res = lpm.http.req('https://github.com/' + $this->address);if $res->getcode() != 200;$this->error = 'Failed to load ' + 'https://github.com/' + $this->address + ': ' + string($res->getcode()) + ' Status code';return ;endif ;endtry ;goto after_lpm_github_init;label lpm_github_init;$this->error = 'Failed to make http connection to the ' + 'https://github.com/' + $this->address;return ;label after_lpm_github_init;try lpm_package_version_load_error;$this->versions = $this->load_versions();endtry ;goto after_lpm_package_version_load_error;label lpm_package_version_load_error;$this->error = 'Failed to load list of versions of '+$this->address+': ' + string(^);return ;label after_lpm_package_version_load_error;endfunc ;@doc "Returns list of versions";func load_versions();$this->default_branch = null;$branches = $this->get_branches();if 'main' in $branches;$this->default_branch = 'main';elif 'dev' in $branches;$this->default_branch = 'dev';elif 'devel' in $branches;$this->default_branch = 'devel';elif 'develop' in $branches;$this->default_branch = 'develop';elif 'master' in $branches;$this->default_branch = 'master';else ;$this->default_branch = $branches[0];endif ;$res = lpm.http.req('https://api.github.com/repos/' + $this->address + '/git/matching-refs/tags');$json_res = json.loads($res->read()->decode());$list = [item['ref'][10:] for item in $json_res];if not $list;$list = [$this->default_branch];endif ;return $list;endfunc ;@doc "Gets a version and file name and loads the file in that version";func string::load_file_content(string $version, string $filename);$url = 'https://raw.githubusercontent.com/' + $this->address + '/' + $version + '/' + $filename;$output = '';try lpm_package_handle_git_command_error;$output = lpm.http.req($url)->read()->decode();endtry ;goto after_lpm_package_handle_git_command_error;label lpm_package_handle_git_command_error;$output = '';label after_lpm_package_handle_git_command_error;return $output;endfunc ;@doc "Loads `LPMfile` of a specify version";func string::load_once_version(string $version);return $this->load_file_content($version, 'LPMfile');endfunc ;@doc "Copies package directory to the target path";func download(string $path, string $version);if not os.path.isdir($lpm.cache_dir);os.mkdir ($lpm.cache_dir);endif ;if os.path.isdir($path);py_load_module ('shutil')->rmtree($path);endif ;$repo_cache_dirname = $lpm.cache_dir + '/' + hash.sha256($this->address + $version);if not os.path.isdir($repo_cache_dirname);system ('git clone https://github.com/' + $this->address + '.git ' + $repo_cache_dirname);$old_cwd = os.getcwd();os.chdir ($repo_cache_dirname);system ('git checkout -b lpm-installation ' + $version);os.chdir ($old_cwd);else ;$old_cwd = os.getcwd();os.chdir ($repo_cache_dirname);system ('git checkout ' + $this->default_branch);system ('git pull');system ('git pull --tags');system ('git branch -D lpm-installation');system ('git checkout -b lpm-installation ' + $version);os.chdir ($old_cwd);pass ;endif ;py_load_module ('shutil')->copytree($repo_cache_dirname, $path);endfunc ;@doc "Returns list of repo branches";func get_branches();$res = lpm.http.req('https://api.github.com/repos/' + $this->address + '/git/matching-refs/heads');$json_res = json.loads($res->read()->decode());$ref_names = [item['ref'][11:] for item in $json_res];return $ref_names;endfunc ;endclass ;@doc "The package model";class Package;func __init__(string $name);$parts = $name->split(':', 1);if len($parts) == 1;$name = 'gh:' + $name;$parts = $name->split(':', 1);endif ;$this->raw_name = $name;$this->type = $parts[0];$this->address = $parts[1];$this->error = null;if $this->type == 'f';$this->driver = lpm.FileDriver($this->address);elif $this->type == 'gh';$this->driver = lpm.GithubDriver($this->address);else ;$this->error = 'Unknow driver "'+$this->type+'"';return ;endif ;if $this->driver->error is not null;$this->error = $this->driver->error;return ;endif ;$this->versions = lpm.version.sort_list($this->driver->versions);endfunc ;@doc "Is package successfully loaded";func bool::is_success();return $this->error is null;endfunc ;@doc """Loads LPMfile config of a specify version of package.     Returns errors as string.     But if process is successful, return lpm.LPMFile object.    """;func string|lpm.LPMFile::get_version(string $version);if $version not in $this->versions and $this->driver->default_branch != $version             and $version not in $this->driver->get_branches();return 'version "' + $version + '" not found';endif ;$config = lpm.LPMFile->loads($this->driver->load_once_version($version));if $config->name == '';return 'file `LPMfile` not found or is invalid';endif ;return $config;endfunc ;endclass ;@doc "This class Handles the `loza_modules` directory";class PackageDirectory;func __init__(string $path = null);if $path is null;if LPM_GLOBAL;$path = string(py_load_module('pathlib')->Path()->home()) + '/.local/lib/loza_modules';else ;$path = os.getcwd() + '/loza_modules';endif ;endif ;$this->path = $path;if not os.path.isdir($path);os.mkdir ($path);endif ;endfunc ;@doc "Checks a package is installed or not. returns false if no, and returns installed verison if yes";func bool|string::is_installed(string $name);if os.path.isdir($this->path + '/' + $name);if os.path.isfile($this->path + '/' + $name + '/.lpm-installed-version');$f = fopen($this->path + '/' + $name + '/.lpm-installed-version', 'r');$ver = $f->read()->strip();$f->close ();return $ver;else ;return false;endif ;else ;return false;endif ;endfunc ;func list[list]::installed_list();$list = os.listdir($this->path);$result = [];$i = 0;while $i < len($list);if os.path.isdir($this->path + '/' + $list[$i]) and $list[$i] != '__lozaam__';$version_f = fopen($this->path + '/' + $list[$i] + '/.lpm-installed-version', 'r');$result->append ([lpm.Package('f:' + $this->path + '/' + $list[$i]), $version_f->read()->strip()]);$version_f->close ();endif ;$i = $i + 1;endwhile ;return $result;endfunc ;@doc "Parses and checks a package query and returns result as boolean";func bool::query(string $query);$or_blocks = [or_block.strip().split('&') for or_block in $query->strip()->split('|')];$i = 0;while $i < len($or_blocks);$j = 0;while $j < len($or_blocks[$i]);$or_blocks[$i][$j] = $or_blocks[$i][$j]->strip();if '>=' in $or_blocks[$i][$j];$or_blocks[$i][$j] = $or_blocks[$i][$j]->split('>=', 1);$or_blocks[$i][$j]->insert (1, '>=');elif '<=' in $or_blocks[$i][$j];$or_blocks[$i][$j] = $or_blocks[$i][$j]->split('<=', 1);$or_blocks[$i][$j]->insert (1, '<=');elif '>' in $or_blocks[$i][$j];$or_blocks[$i][$j] = $or_blocks[$i][$j]->split('>', 1);$or_blocks[$i][$j]->insert (1, '>');elif '<' in $or_blocks[$i][$j];$or_blocks[$i][$j] = $or_blocks[$i][$j]->split('<', 1);$or_blocks[$i][$j]->insert (1, '<');elif '!=' in $or_blocks[$i][$j];$or_blocks[$i][$j] = $or_blocks[$i][$j]->split('!=', 1);$or_blocks[$i][$j]->insert (1, '!=');elif '=' in $or_blocks[$i][$j];$or_blocks[$i][$j] = $or_blocks[$i][$j]->split('=', 1);$or_blocks[$i][$j]->insert (1, '=');else ;$or_blocks[$i][$j] = [$or_blocks[$i][$j]];endif ;$j = $j + 1;endwhile ;$i = $i + 1;endwhile ;$installed_packages = $this->installed_list();$only_package_names = [ins_pkg[0]->get_version(ins_pkg[1])->name for ins_pkg in $installed_packages];$pkg_by_version = {};$x = 0;while $x < len($installed_packages);$tmp_pkg_name = $installed_packages[$x][0]->get_version($installed_packages[$x][1])->name;$pkg_by_version[$tmp_pkg_name] = $installed_packages[$x][1];$x = $x + 1;endwhile ;$i = 0;while $i < len($or_blocks);$once_result = false;$j = 0;while $j < len($or_blocks[$i]);if len($or_blocks[$i][$j]) == 1;$once_result = $or_blocks[$i][$j][0]->strip() in $only_package_names;elif len($or_blocks[$i][$j]) == 3;$once_result = $or_blocks[$i][$j][0]->strip() in $only_package_names;if $once_result is true;$pkg_name = $or_blocks[$i][$j][0]->strip();$op = $or_blocks[$i][$j][1]->strip();$version = $or_blocks[$i][$j][2]->strip();$current_version = $pkg_by_version[$pkg_name]->strip();if $op == '=';$once_result = lpm.version.compare($version, $current_version) == 0;elif $op == '!=';$once_result = lpm.version.compare($version, $current_version) != 0;elif $op == '>';$once_result = lpm.version.compare($version, $current_version) == 1;elif $op == '<';$once_result = lpm.version.compare($version, $current_version) == -1;elif $op == '>=';$once_result = lpm.version.compare($version, $current_version) >= 0;elif $op == '<=';$once_result = lpm.version.compare($version, $current_version) <= 0;else ;$once_result = false;endif ;endif ;else ;$once_result = false;endif ;if $once_result is false;break ;endif ;$j = $j + 1;endwhile ;if $once_result is true;return true;endif ;$i = $i + 1;endwhile ;return false;endfunc ;endclass ;class Installer;$error = null;func install(lpm.Package $pkg, string $version, lpm.PackageDirectory $pkg_dir);$ver = $pkg->get_version($version);try lpm_installer_handle_download_error;$pkg->driver->download ($pkg_dir->path + '/' + $ver->name, $version);endtry ;goto after_lpm_installer_handle_download_error;label lpm_installer_handle_download_error;$this->error = str(^);return ;label after_lpm_installer_handle_download_error;$f = fopen($pkg_dir->path + '/' + $ver->name + '/.lpm-installed-version', 'w');$f->write ($version);$f->close ();endfunc ;endclass ;endns ;$__ismain__ = False;ns lpm;ns commands;@doc """This command shows details of packages\nUsage: lpm show [options...] package1 package2 ...\n\nOptions:\n    --versions: shows list of versions of packages\n""";func show_cmd($args);$result = $args->validate({        'min_args': 1,        'options': {            '--versions': {            }        }    });if $result is not true;lpm.print_warn 'lpm: show: ' + $result + '\n';return 1;endif ;lpm.print_info "Loading packages list...\n";lpm.print_info "========================\n";$i = 0;while $i < len($args->arguments);$pkg_name = $args->arguments[$i]->split('=');$pkg_version = null;if len($pkg_name) > 1;$pkg_version = $pkg_name[1];endif ;$pkg_name = $pkg_name[0];$pkg = lpm.Package($pkg_name);if not $pkg->is_success();lpm.print_err 'Error: ' + $pkg->error + '\n';else ;if $pkg_version is null;$pkg_version = $pkg->versions[-1];endif ;$version = $pkg->get_version($pkg_version);if typeof($version) == string;lpm.print_err 'Error: ' + $version + '\n';else ;if $args->has_option('--versions');lpm.print_log $pkg_name + ': ' + ', '->join($pkg->versions) + '\n';else ;$j = 0;$version->raw_options['version'] = $pkg_version;$keys = list($version->raw_options->keys());$keys->insert (0, $keys->pop($keys->index('name')));while $j < len($keys);$key = $keys[$j];if typeof($version->raw_options[$key]) == list;if $version->raw_options[$key];lpm.print_log $key->capitalize() + ': ' + ', '->join($version->raw_options[$key]) + '\n';endif ;else ;if $version->raw_options[$key] != '';if $key == 'description_file';lpm.print_log 'Long Description: ' + '\n'.join(['  ' + line for line in $pkg->driver->load_file_content($pkg_version, $version->raw_options[$key])->splitlines()])[2:] + '\n';else ;lpm.print_log $key->capitalize() + ': ' + string($version->raw_options[$key]) + '\n';endif ;endif ;endif ;$j = $j + 1;endwhile ;endif ;lpm.print_info "========================\n";endif ;endif ;$i = $i + 1;endwhile ;return 0;endfunc ;endns ;endns ;$__ismain__ = False;$__ismain__ = False;$__ismain__ = False;ns lpm;@doc "This class solves the depends/conflicts";class DependencySolver;$for_install = [];$for_remove = [];$error = null;@doc "Add a package for install";func install(lpm.Package $pkg, string $version);$this->for_install->append ([$pkg, $version]);endfunc ;endclass ;endns ;$__ismain__ = False;$__ismain__ = False;ns lpm;ns commands;@doc """Generates loza_modules/load.loza script\nUsage: lpm gen-loader [options...]\n""";func gen_loader_cmd($args);$result = $args->validate({    });if $result is not true;lpm.print_warn 'lpm: gen-loader: ' + $result + '\n';return 1;endif ;$pkg_dir = lpm.PackageDirectory();$all_paths = [];$i = 0;$list = os.listdir($pkg_dir->path);while $i < len($list);if os.path.isdir($pkg_dir->path + '/' + $list[$i]) and $list[$i] != '__lozaam__';$path = lpm.LPMFile->load_f($pkg_dir->path + '/' + $list[$i] + '/LPMfile')->path;$j = 0;while $j < len($path);$path[$j] = os.path.abspath($pkg_dir->path + '/' + $list[$i] + '/' + $path[$j]);$j = $j + 1;endwhile ;$all_paths = [*$all_paths, *$path];endif ;$i = $i + 1;endwhile ;$loza_content = '$all_paths = ' + repr($all_paths) + '; python("os.environ[\'LOZAPATH\'] = \';\'.join(self.get_var(\'all_paths\')); self.bootstrap_modules()"); free("all_paths")';$f = fopen($pkg_dir->path + '/load.loza', 'w');$f->write ($loza_content);$f->close ();lpm.print_info 'Loader `' + $pkg_dir->path + '/load.loza' + '` Generated successfully.\n';return 0;endfunc ;endns ;endns ;$__ismain__ = False;ns lpm;ns commands;@doc """Installs packages\nUsage: lpm install [options...] package1 package2\n""";func install_cmd($args);$result = $args->validate({        'min_args': 1,    });if $result is not true;lpm.print_warn 'lpm: install: ' + $result + '\n';return 1;endif ;lpm.print_info "Loading packages list...\n";lpm.print_info "========================\n";$packages = [];$i = 0;while $i < len($args->arguments);$pkg_name = $args->arguments[$i]->split('=');$pkg_version = null;if len($pkg_name) > 1;$pkg_version = $pkg_name[1];endif ;$pkg_name = $pkg_name[0];$pkg = lpm.Package($pkg_name);if not $pkg->is_success();lpm.print_err 'Error: ' + $pkg->error + '\n';else ;if $pkg_version is null;$pkg_version = $pkg->versions[-1];endif ;$version = $pkg->get_version($pkg_version);if typeof($version) == string;lpm.print_err 'Error: ' + $version + '\n';else ;$packages->append ([$pkg, $pkg_version]);endif ;endif ;$i = $i + 1;endwhile ;if not $packages;return 1;endif ;$pkg_dir = lpm.PackageDirectory();$packages = [*$pkg_dir->installed_list(), *$packages];$solver = lpm.DependencySolver();$i = 0;while $i < len($packages);$solver->install ($packages[$i][0], $packages[$i][1]);if $solver->error is not null;lpm.print_err 'Solver error: ' + $solver->error + '\n';return 2;endif ;$i = $i + 1;endwhile ;lpm.print_info 'Installing the Packages...\n';lpm.print_info '==========================\n';$i = 0;while $i < len($solver->for_install);$version = $solver->for_install[$i][0]->get_version($solver->for_install[$i][1]);$installed = $pkg_dir->is_installed($version->name);if $installed == false;lpm.print_log 'Installing ' + $version->name + ' (' + $solver->for_install[$i][1] + ') ...\n';else ;if lpm.version.compare($solver->for_install[$i][1], $installed) == 0;lpm.print_log 'Package ' + $version->name + ' currently installed (' + $installed + ') ...\n';$i = $i + 1;continue ;elif lpm.version.compare($solver->for_install[$i][1], $installed) == 1;lpm.print_log 'Updating ' + $version->name + ' (to ' + $solver->for_install[$i][1] + ') ...\n';else ;lpm.print_log 'Downgrading ' + $version->name + ' (to ' + $solver->for_install[$i][1] + ') ...\n';endif ;endif ;$installer = lpm.Installer();$installer->install ($solver->for_install[$i][0], $solver->for_install[$i][1], $pkg_dir);if $installer->error is not null;perror 'Error: ' + $installer->error + '\n';return 1;endif ;$i = $i + 1;endwhile ;lpm.commands.gen_loader_cmd (lpm.cmdline.parse_args([]));return 0;endfunc ;endns ;endns ;$__ismain__ = False;$__ismain__ = False;ns lpm;ns commands;@doc """Shows list of installed packages\nUsage: lpm list [options]\n""";func list_cmd($args);lpm.print_info 'Installed packages:\n';lpm.print_info '===================\n';$pkg_dir = lpm.PackageDirectory();$packages = $pkg_dir->installed_list();$i = 0;while $i < len($packages);$pkg = $packages[$i][0]->get_version($packages[$i][1]);lpm.print_log $pkg->name + ' (' + $packages[$i][1] + ')';if $pkg->description != '';lpm.print_info ' - ' + $pkg->description;endif ;lpm.print_log '\n';$i = $i + 1;endwhile ;endfunc ;endns ;endns ;$__ismain__ = False;$__ismain__ = False;ns lpm;ns commands;@doc """Clears the downloaded packages cache\nUsage: lpm clear-cache""";func clear_cache_cmd($args);if os.path.isdir($lpm.cache_dir);py_load_module ('shutil')->rmtree($lpm.cache_dir);endif ;lpm.print_info "Cache has been cleared successfully\n";endfunc ;endns ;endns ;$__ismain__ = False;$__ismain__ = False;import_once "@sys";ns lpm;ns commands;@doc """Runs a script from LPMfile\nUsage: lpm run [script name]\nDefining the scripts in LPMfile: script [script name without space] [loza script file path] [arguments to script (optional)]\nExample: script build scripts/build.loza""";func run_cmd($args);$pkg = lpm.Package('f:.');if not $pkg->is_success();lpm.print_err 'lpm: run: faild to load LPMfile: ' + $pkg->error + '\n';return 1;endif ;$pfile = $pkg->get_version($pkg->versions[-1]);$scripts = $pfile->script;$default_script = $pfile->default_script;$parsed_scripts = {};$i = 0;while $i < len($scripts);$script_name = $scripts[$i]->strip()->split(' ', 1);if len($script_name) <= 1;$parsed_scripts[$script_name[0]] = None;else ;$parsed_scripts[$script_name[0]] = $script_name[1];endif ;$i = $i + 1;endwhile ;if $args->arguments;$script_to_run = $args->arguments[0];else ;$script_to_run = $default_script;endif ;if $script_to_run is None;lpm.print_err "lpm: run: There is not any default script. You should give a name\n";return 1;endif ;if $script_to_run not in $parsed_scripts;lpm.print_err "lpm: run: script \""+$script_to_run+"\" not found in LPMfile\n";return 1;endif ;if $parsed_scripts[$script_to_run] is None;lpm.print_err "lpm: run: script \""+$script_to_run+"\" has not any target\n";return 1;endif ;$file_to_run = $parsed_scripts[$script_to_run];$arguments = $args->arguments[1:];return py_load_module('subprocess')->run([$sys.lozaexe, $file_to_run, *$arguments])->returncode;endfunc ;endns ;endns ;$__ismain__ = False;ns lpm;ns commands;$list = {    'index': index_cmd,    'show': show_cmd,    'install': install_cmd,    'gen-loader': gen_loader_cmd,    'list': list_cmd,    'clear-cache': clear_cache_cmd,    'run': run_cmd,};endns ;endns ;$__ismain__ = True;ns lpm;func main(array[string] $argv);$is_global = false;if '-g' in $argv;$argv->pop ($argv->index('-g'));$is_global = true;endif ;if '--global' in $argv;$argv->pop ($argv->index('--global'));$is_global = true;endif ;$q_flag_count = 0;if '-q' in $argv;$argv->pop ($argv->index('-q'));$q_flag_count = 1;endif ;if '-qq' in $argv;$argv->pop ($argv->index('-qq'));$q_flag_count = 2;endif ;if '-qqq' in $argv;$argv->pop ($argv->index('-qqq'));$q_flag_count = 3;endif ;if '-qqqq' in $argv;$argv->pop ($argv->index('-qqqq'));$q_flag_count = 4;endif ;define ('LPM_GLOBAL', $is_global);define ('LPM_LOG_INFO', $q_flag_count <= 0);define ('LPM_LOG_LOG', $q_flag_count <= 1);define ('LPM_LOG_WARN', $q_flag_count <= 2);define ('LPM_LOG_ERR', $q_flag_count <= 3);$args = lpm.cmdline.parse_args($argv);$command_name = 'index';if len($args->arguments) > 0;$command_name = $args->arguments[0];if not $command_name in list($lpm.commands.list->keys());perror ('lpm: unknow command "' + $command_name + '"\n');return 1;endif ;endif ;$command_func = $lpm.commands.list[$command_name];if $args->arguments;$args->arguments->pop (0);endif ;if $args->has_option('--help');println $command_func->__docstring__;$code = 0;else ;$code = $command_func($args);endif ;if $code is null;$code = 0;endif ;$code = int($code);exit ($code);endfunc ;endns ;lpm.main ($argv[1:]);